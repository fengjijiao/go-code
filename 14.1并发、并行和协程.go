package main

import (
	"flag"
	"fmt"
	"runtime"
	"time"
)

//14.1.1什么是协程
//在协程和操作系统线程之间并无一一对应关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在它们之上的；协程调度器在Go运行时很好的完成了这个工作。
//协程工作在相同的地址空间中，所以共享内存的方式一定是同步的；这个可以使用sync包来实现，不过我们很不鼓励这样做：Go使用channels来同步协程。
//当系统调用（比如等待IO）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。
//协程是轻量的，比线程更轻。它们痕迹非常不明显（使用少量的内存和资源）：使用4K的栈内存就可以在堆中创建它们。因为创建非常廉价，必要的时候可以轻松创建并运行大量的协程（在同一个地址空间中100,000个连续的协程）。
//并且它们对栈进行了分割，从而动态的增加（或缩减）内存的使用；栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出之后自动释放。

//协程可以运行在多个操作系统线程之间，也可以运行在线程之内，让你可以以很小的内存占用就可以处理大量的任务。由于操作系统线程上的协程时间片，你可以使用少量的操作系统线程就能拥有任意多个提供服务的协程，而且Go运行时可以聪明的意识到哪些协程被阻塞了，暂时搁置它们并处理其他协程。
//存在两种并发方式：确定性的（明确定义排序）和非确定性的（加锁/互斥从而未定义排序）。Go的协程和通道理所当然的支持确定性的并发方式（例如通道具有一个sender和一个receiver）。我们会在14.7中使用一个常见的算法问题（工人问题）来对比两种处理方式。

//协程是通过关键字go调用（或执行）一个函数或者方法来实现的（也可以是匿名或者lambda函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并分配了独立的栈。

//协程的栈会根据需要进行伸缩，不会出现栈溢出；开发者无需关心栈的大小。当协程结束时，它会静默退出：用来启动这个协程的函数也不会得到任何返回值。

//任何Go程序都必须有的main()函数也可以看做是一个协程，尽管它并没有通过go来启动。协程可以在程序初始化的过程中运行（在init()中）。

//在一个协程中，比如它需要进行非常密集的运算，你可以在运算循环周期中使用runtime.Gosched(): 这会让出处理器，允许运行其他协程；它并不会是当前协程挂起，所以它会自动恢复运行。使用Gosched()可以使计算均匀分布，使通信不至于迟迟得不到响应。

//14.1.4如何用命令行指定使用的核心数量
//使用flag包，如下：
var numCores = flag.Int("n", 2, "number of cpu cores to use")

func main() {
	flag.Parse()
	runtime.GOMAXPROCS(*numCores)
}

//协程可以通过调用runtime.Goexit()来停止，尽管没有必要。
func main() {
	fmt.Println("in main()")
	go longWait()
	go shortWait()
	fmt.Println("about to sleep in main()")
	//sleep works with a duration in nanoseconds (ns)!
	time.Sleep(10 * 1e9)
	fmt.Println("at the end of main()")
}

func longWait() {
	fmt.Println("beginning longWait()")
	time.Sleep(5 * 1e9)//5s
	fmt.Println("end of longWait()")
}

func shortWait() {
	fmt.Println("beginning shortWait()")
	time.Sleep(2 * 1e9)//2s
	fmt.Println("end of shortWait()")
}

//main函数暂停10s从而确定它会在另外两个协程结束之后结束。如果不这样，main函数会提前结束，longWait则可能无法完成。如果我们不在main中等待，协程会随着程序的结束而消亡。
//当main函数返回的时候，程序退出：它不会等待任何其他非main协程的结束。这也是为什么服务器程序中，每一个请求都会启动一个协程来处理，server函数必须保持运行状态。通常使用一个无限循环来达到这样的目的。
//另外，协程是独立的处理单元，一旦陆续启动一些协程，你无法确定它们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序。
//协程更有用的一个例子应该是在一个非常长的数组中查找一个元素。
//将数组分割为若干个不重复的切片，然后给每一个切片启动一个协程进行查找计算。这样许多并行的协程可以用来进行查找任务，整体的查找时间会缩短（除以协程数量）。


//14.1.5 Go协程(goroutines)和协程(coroutines)
//在其它语言中，比如C#，Lua或者Python都有协程的概念。这个名字表明它和Go协程有点相似，不过有两个不同：
//1.Go协程意味着并行（或者可以以并行的方式部署），协程一般来说部署这样的
//2.Go协程通过通道来通信；协程通过让出和恢复操作来通信
//Go协程比协程更强大，也很容易从协程的逻辑复用到Go协程。