package main

//Go没有像Java和.NET下那样的try/catch异常机制：不能执行抛出异常操作。但是有一套defer-panic-and-recover机制(13.2-13.3)。
//Go的设计者觉得try/catch机制的使用太滥用了，而且从底层向更高的层级抛出异常太耗费资源了。他们给Go设计的机制也可以捕捉异常，但是更轻量，并且只应该作为（处理错误的）最后手段。
//Go是怎么处理普通错误的呢？通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值---如果返回nil，则没有错误发生---并且主调（calling）函数总是应该检查收到的错误。

//永远不要忽略错误，否则可能会导致程序崩溃！

//处理错误并且在函数发生错误的地方给用户返回错误信息：
//照这样处理就算真的出了问题，你的程序也能继续运行并且通知给用户。panic and recover是用来处理真正的异常（无法预测的错误）而不是普通的错误。
//库函数通常必须返回某种错误提示给主调（calling）函数。
//在前名的章节中我们了解到了Go检查和报告错误条件的惯用方式有：
//1.产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是nil就是成功，非nil就是发生了错误。
//2.为了防止发生错误时正在执行的函数（如果有必要的话甚至会是整个程序）被中止，在调用函数后必须检查错误。
//下面这段来自pack1包的代码Func1测试了它的返回值：
//if value, err := pack1.Func1(param1); err != nil {
//	fmt.Printf("Error %s in pack1.Func1 with parameter %v\n", err.Error(), param1)
//	return
//}else {
//	//Process(value)
//}
//为了更清晰的代码，应该总是使用包含错误值变量的if复合语句。