package main

import "fmt"

func main() {
	f := Adder()
	fmt.Print(f(1), "\n")
	fmt.Print(f(20), "\n")
	fmt.Print(f(300), "\n")
	/**
	1
	21
	321
	*/
	/**
	在多次调用中，变量x的值是被保留的，闭包函数保留并积累其中的变量的值，不管外部函数退出与否，它都能继续操作外部函数中的局部变量。
	 */
	var x int = 0
	f2 := AddP(x)
	fmt.Print(f2(1), "\n")
	fmt.Print(f2(20), "\n")
	fmt.Print(f2(300), "\n")
	/**
	1
	21
	321
	*/
}

func Adder() func(int) int {//包装函数
	var x int
	return func(i int) int {//匿名函数被称之为闭包：它们被允许调用定义在其他环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。也即是：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到（闭包）被销毁。
		x += i
		return x
	}
}

func AddP(x int) func(int) int {//包装函数
	return func(i int) int {//匿名函数被称之为闭包：它们被允许调用定义在其他环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。也即是：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到（闭包）被销毁。
		x += i
		return x
	}
}